import cv2
import torch
import numpy as np
from ultralytics import YOLO
import os

# --------------------------------------------------
# Configuration and Constants
# --------------------------------------------------
# --- Model and Camera Settings ---
MODEL_PATH = "best.pt"         # Path to your trained YOLOv8 pose model
VIDEO_SOURCE = 0              # Webcam index (0 for built-in, 1 for external, etc.)
FRAME_WIDTH = 1280
FRAME_HEIGHT = 720

# --- Detection and Measurement Settings ---
CONF_THRESHOLD = 0.5           # Confidence threshold for detecting keypoints
PX_TO_MM_RATIO = 0.9166        # IMPORTANT: This ratio must be calibrated for your specific camera setup and distance to the object.

# --- Drawing and Display Settings ---
KP_COLOR = (0, 255, 0)         # Color for valid keypoints (Green)
LINE_COLOR = (255, 0, 0)       # Color for lines connecting keypoints (Blue)
TEXT_COLOR = (0, 0, 255)       # Color for keypoint labels (Red)
MEASURE_TEXT_COLOR = (0, 255, 255) # Color for distance measurements (Yellow)
INFO_TEXT_COLOR = (0, 255, 0)  # Color for the total length text (Green)
WINDOW_NAME = "Rod Length Measurement"

# --------------------------------------------------
# Helper Functions
# --------------------------------------------------
def euclidean_distance(p1, p2):
    """Calculates the Euclidean distance between two points."""
    return np.linalg.norm(np.array(p1) - np.array(p2))

def draw_results(frame, keypoints, confidences, conf_threshold, px_to_mm):
    """
    Processes and draws keypoints, lines, and measurements on the frame.
    Returns the total calculated length of the rod.
    """
    valid_points = []
    # Create a list of valid keypoints based on confidence score
    for kp, conf in zip(keypoints, confidences):
        if conf > conf_threshold:
            px, py = int(kp[0]), int(kp[1])
            valid_points.append((px, py))
            # Draw a circle on the keypoint
            cv2.circle(frame, (px, py), 6, KP_COLOR, -1)
        else:
            # Use None as a placeholder for low-confidence keypoints
            valid_points.append(None)

    total_length_mm = 0
    # Draw lines and calculate distances between consecutive valid points
    for i in range(len(valid_points) - 1):
        pt1 = valid_points[i]
        pt2 = valid_points[i+1]

        # Only draw a line if both points are valid
        if pt1 is not None and pt2 is not None:
            # Draw the connecting line
            cv2.line(frame, pt1, pt2, LINE_COLOR, 2)

            # Calculate and display the distance for this segment
            distance_px = euclidean_distance(pt1, pt2)
            distance_mm = distance_px * px_to_mm
            total_length_mm += distance_mm

            # Put text with the segment length
            mid_point = ((pt1[0] + pt2[0]) // 2, (pt1[1] + pt2[1]) // 2 - 10)
            cv2.putText(frame, f"{distance_mm:.1f} mm", mid_point,
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, MEASURE_TEXT_COLOR, 2)

    return total_length_mm

# --------------------------------------------------
# Main Execution Block
# --------------------------------------------------
def main():
    # --- 1. Load Model and Set Device ---
    if not os.path.exists(MODEL_PATH):
        print(f"Error: Model file not found at '{MODEL_PATH}'")
        return

    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print(f"Running on device: {device}")
    model = YOLO(MODEL_PATH)

    # --- 2. Initialize Webcam ---
    cap = cv2.VideoCapture(VIDEO_SOURCE)
    if not cap.isOpened():
        print(f"Error: Could not open video source {VIDEO_SOURCE}.")
        return

    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
    print("Webcam opened successfully.")

    # --- 3. Main Loop for Real-time Inference ---
    while True:
        ret, frame = cap.read()
        if not ret:
            print("Failed to grab frame. Exiting...")
            break

        # --- Run Inference ---
        results = model(frame, device=device, verbose=False)

        # --- Process Results ---
        # Assuming the first detected object is the one of interest
        if results and results[0].keypoints and results[0].keypoints.shape[1] > 0:
            keypoints = results[0].keypoints.xy.cpu().numpy()[0]
            confidences = results[0].keypoints.conf.cpu().numpy()[0]

            # Draw keypoints and calculate length
            total_length_mm = draw_results(frame, keypoints, confidences, CONF_THRESHOLD, PX_TO_MM_RATIO)

            # Display the total calculated length on the frame
            cv2.putText(frame, f"Total Rod Length: {total_length_mm:.1f} mm", (50, 50),
                        cv2.FONT_HERSHEY_SIMPLEX, 1, INFO_TEXT_COLOR, 2, cv2.LINE_AA)

        # --- Display the Frame ---
        cv2.imshow(WINDOW_NAME, frame)

        # --- Exit Condition ---
        if cv2.waitKey(1) & 0xFF == ord('q'):
            print("Exiting program.")
            break

    # --- 4. Cleanup ---
    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
